const int bufSize = 512;

Standard streams:
string s1, s2;
cin >> s1 >> s2; // reads s1 first, then s2, kinda backwards
getline(cin, s1);

Structure:
struct Sales_item {
    // members are public by default
    private:
        std::string isbn;
        unsigned units_sold;
        double revenue;
};

Pointers (on stack):
int integer = 3;
int *intPointer = &integer;

References:
int integer = 1024;
int &intReference = integer;
intReference += 1; // integer is now 1025

Typedef:
typedef double wages;
wages hourly, weekly;

Enumeration:
enum open_modes {input, output, append};
enum Points {a = 2, b, c = 3, d}; // b is 3, d is 4
Points pt3d = a;

Class:
class Sales_item {
    public:
        // public field and methods
    private:
        std::string isbn;
        unsigned units_sold;
        double revenue;
};

Namespace:
using namespace std
using std::string
namespace namespace_name {
    int x = 0, y = 2;
}

String:
string s1("value"); // String s1 = new String("value"); for Java
string s2(s1); // clone, just like String s2 = new String(s1); for Java

Vector:
vector<string> stringVector(10, "a"); // construct 10 strings, each initialized to "a"
- .empty(), .size(), .push_back(t) (aka .append()), v[n]

Iterator:
vector<int>::iterator iter;



_______ new _______, A tour of C++

types:
- bool
- char, sizeof(char) = 1
- int, sizeof(int), often 4
- double
- unsigned, non negative integer

auto, like let
new, delete
const (evaluated at run time), constexpr (evaluated at compile time, place data in read only memory). int a = 5;const int b = square(a);// allowed, not for constexpr
constexpr double square(double x) {return x * x;}

char v[6]; // 6 must be a constexpr
char* p = &v[3];
char x = *p;

nullptr, double* pd = nullptr;

struct is just a class with all of its elements public
enum, nifty little construct: enum class Color {red, green, blue}; Color col = Color::red;

union Value {
    char* s;
    int i;
}

namespace someNamespace {
}
#include "Vector.h"
#include <cmath>

throw out_of_range{"Vector::operator[]"};
try {
} catch (out_of_range) {
    throw; // rethrow
}
void user(int sz) noexcept { // supposed to not throw errors
}
out_of_range
length_error
static_assert(4 <= sizeof(int), "integers are too small"); // detecting errors at compile-time

- concrete classes
- abstract classes
- class hierarchies

templates -- generics

"industrial-strength complex"
default constructors should be used, to make sure there aren't any uninitialized variables

what's the whole passed by value thing

"Resource Acquisition Is Initialization", avoiding "naked" new and delete

explicit overriding, void move(Point to) override; // kinda like @Override annotation in java

if (Smiley* p = dynamic_cast<Smiley*>(ps)) {
    // is the Smiley pointer
} else {
    // not the Smiley pointer
}
// also, use dynamic_cast with pointer where failure is an alternative, while  using it with referenes where failure is a failure

essential default methods:
class X {
public:
    X (Sometype); // ordinary constructor
    X (); // default constructor
    X (const X&); // copy constructor
    X (X&&); // move constructor
    X& operator = (const X&); // copy assignment, clean up target and copy
    X& operator = (X&&); // move assignment, clean up target and move
    ~X(); // destructor, clean up
}
These will be automatically generated by the compiler. If Y(Y&&) = default; meaning I really want the default move constructor, then it won't auto generate

So, resources:
- memory
- locks
- sockets
- file handles
- thread handles

RAII is pervasive:
- memory (string, vector, map, unordered_map)
- files (ifstream, ofstream)
- threads (thread)
- locks (lock_guard, unique_lock)
- general objects (unique_ptr and shared_ptr)

I still haven't gotten use to the idea of managing my own resources, and putting them in a handle like what the book is suggesting

For suppressing operations, do Shape(const Shape&) = delete; // no copy operations. This is ideal cuz default copy or move is a disaster

templates:
template <typename T> // put these in front of any being that carries T.

range-for loop, define namespace-wide T* begin(Vector<T>& x)

also function objects, kinda like anonymous classes that implement a specific interface. Wow, why it is so messed up?
"Function objects used to specify the meaning of key operations of a general algorithm (such as Less_than for count()), are often referred to as policy objects"
[&](int a) {return a < x;} // "&" is for capturing every variable inside the function object, can also use &x. To get a copy, use =x

template<typename T, typename... Tail>
void f(T head, Tail... tail) {
    g(head);
    f(tail...); // recursively call f() with the rest of the arguments. Notice the current function is named f
}

aliases: using size_t = unsigned int;

regular expression: regex pat(R"(\\w{2}\\s*\\d{5}(-\\d{4})?)") // starts with R"( and ends with ")
in <regex>:
- regex_match()
- regex_search()
- regex_replace()
- regex_iterator: iterate over matches and submatches
- regex_token_iterator: iterate over non-matches

cin >> string_var
getline(cin, string_var)

while (cin) {
    for (int i; cin >> i;) {
        // use the integer
    }
    if (cin.eof()) {
        // okay, we reached end of file
    } else if (cin.fail()) { // potentially recoverable error
        cin.clear();
        char ch;
        if (cin >> ch) {
            switch() {}
        }
    }
}

formatting:
constexpr double d = 123.456;
cout << d << "; " // default format
    << scientific << d << "; "
    << hexfloat << d << "; "
    << fixed << d << "; "
    << defaultfloat << d << "\n";
cout.precision(8); // when outputting a float, it grabs the first 8 digits. If it's an integer then it remained unchanged.
use stringstream for in-memory formatting

template<typename T>
using Iterator = typename T::iterator
template<typename C, typename V>
vector<Iterator<C>> find_all(C& c, V v) {
    vector<Iterator<C>> res;
    for (auto p = c.begin(); p != c.end(); ++p) {
        if (*p == v) {
            res.push_back(p);
        }
    }
    return res;
}

unique_copy(vec.begin(), vec.end(), back_inserter(vec))

ostream_iterator<string> oo {cout};
*oo = "Hello, ";
++oo;
*oo = "world!\n";

Doing math:
errno = 0;
sqrt(-1);
if (errno == EDOM) // EDOM for error in the domain, ERANGE for error in the range
    cout << "sqrt() not defined for negative number"

